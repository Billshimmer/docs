

### 前言

对于现代web应用开发，特别是那些有复杂交互的网站应用，最大的开销就是发送js代码给我们的用户,不过让人不满意的是现在的应用的js代码太多了，后果也是让人崩溃，(卡顿，白屏，点击滑动交互时无响应)。

### 简单策略

针对上述问题，我们总结出了一些策略，目标是可以高效稳定地把代码发送用户的设备上。

1. 确保足够快,在当前页面仅仅加载我们需要的js资源

2. 确保足够少,性能对比并且代码优化，使用多维度来比较js bundle的大小

3. 确保相对精简,需要在开发中拥有足够的优化意识,不应该因为一小块需要而带入庞大的依赖

4. 每一次交互都不应该超过一个标准时间(1s~2s), 在指定的交互场景下，应该针对优化, 难以想象打开一个列表要等5秒以上的时间(除非你不想用这个功能)

5. 客户端js(以组件和类库为边界)如果不能优化用户体验，那你应该好好想想我们需不需要它。

### 所谓需求

现在每当一个用户进入一个网站应用的时候, 服务器可能会下载一大堆的script代码, 一个中等体量的应用在压缩优化之后的体积大概在350kb左右,然而浏览器需要进一步去执行解压后为1MB以上的js代码。


tips: 如果不确定线上应用的响应、加载以及各种等等的情况, 我们可以借助 [Lighthouse](https://github.com/GoogleChrome/lighthouse) 来协助我们知晓页面的性能情况。


当前现状: 拥有过大不合理代码体量的网站应用根本无法被大范围区域的用户访问，从统计上来说，用户也不会有耐心来等待加载。

做一个简单的统计: 现在我们开发的js bundle包主要分为以下几个:


1. 客户端框架(R (react) | V (vue) | A (angular)) 或者 UI框架
2. 一种数据解决方案(R - Redux | V - Vuex )
3. 兼容低版本浏览器: Polyfills
4. 工具型类库: lodash, Moment + locales
5. UI组件集成库(比如: buttons, headers, sidebars ...)


这些类库框架包含得越多，就需要更长的时间来加载一个页面。

### 页面加载过程

1. 发生什么 => 我们传送一些内容到屏幕上(导航栏是否可以使用? 服务器是够可以响应我们的请求)
2. 是否有用 => 当我们绘制完我们的前端页面之后，允许用户从应用的体验和互动中获取价值
3. 是否可用 => 当用户在有意义地交互和体验的时候，是否是可用的



我们可以直观地看一下网站加载时间对于用户的感觉:

![时间动图](https://static.gitpapa.com/1_ow6eliCJiSeX7-Ri4hOA5Q.gif)

### 如何看待代码

想要提高页面加载速度，必须要足够快，而一份有价值的代码从服务器抵达用户设备终端需要经历下载--解析--编译--执行这四个步骤。下面是网络搜集来的关于页面脚本的时间开销的细节:

![时间消耗分布](https://static.gitpapa.com/1_NPtzv8seEPgfftIBQ1Fh7Q.png)


值得注意的是代码和资源在前端开发中并不能等同看待:![大小对比](https://static.gitpapa.com/0_fFKw1fQlh2zs_BuT.jpeg)
或许它们都花费了相同的时间下载，但是后续的处理开销却相去甚远。
一张JPEG图片解码和绘制就能展现在屏幕上，而JavaScript代码不仅要完成四个步骤，还需要完成许多其他步骤，彼此之间的花销并不相同。


### 如何看待用户

1. 从pc时代到现在的pc和移动互联网共存时代，用户使用场景的变化直接导致了我们开发的业务需求变化(纯pc ==> pc&mobile 共存)

2. 在移动手机环境下，用户之间的网络以及手机性能差异较大，我们需要考虑用户在较差环境依旧可以高效地访问我们的服务。

3. 设备之间差异需要我们去解决对应的兼容性问题，不同设备可以直观地反应在JavaScript运行时间上: ![大小对比](https://static.gitpapa.com/1_fA-I6ujh-3sJAZVKGsQYLw.png)

4. 开发或者接入监控埋点系统例如(**国内[sentry](https://github.com/getsentry/sentry) | 国外[Google Analytics](https://developers.google.com/analytics/devguides/collection/analyticsjs)**)，数据可视化跟踪线上应用情况。(谁都没法准确知道线上应用现在是什么样子，就算是开发者自己，对代码负责就是对用户负责)

### 磨刀不误砍柴工

在JavaScript开发社区中有许多方便好用的工具可以来帮助我们分析代码。
我自己熟知的主要是这几个**[Webpack Bundler Analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer), [Source Map Explorer](https://www.npmjs.com/package/source-map-explorer) 和 [Bundle Buddy](https://github.com/samccone/bundle-buddy)**。


这些工具直观地可视化显示出你的js代码包：高亮出大体量的类库，重复的代码，以及一些你不需要但是被引入的依赖。

![代码分析](https://static.gitpapa.com/1_AzG1zXjLLAdJPAtQ9uvT5g.png)


如果你使用webpack的话，你可以借鉴一下这些[常用类库](https://github.com/GoogleChromeLabs/webpack-libs-optimizations)来，或许可以派上用场。


在这些工具的帮助下，我们可以很方便地知道哪些代码没有被使用，去掉这些冗余的代码。


### 砍柴时刻

在实际开发过程中，我们需要有一定的模式来规划我们的代码工程，主要是针对我们应用交付和性能优化。

**PERL模式**


PERL是一种结构化和渐进式迭代的模式，强调应用交付和启动的性能:

1. 推送(PUSH) - 为初始网址路由推送关键资源。
2. 渲染(RENDER) - 渲染初始路由。
3. 预缓存(PRECACHE) - 预缓存剩余路由。
4. 延迟加载(LAZY-LOAD) - 延迟加载并按需创建剩余路由。

PERL更多的是一种思维模式和提高移动网络性能的长期愿景，不只是单纯的指定技术或者解决方案。除开上述四个标准，这个模式竭力在以下方面进行优化:

1. 尽可能较少交互时间(尤其在第一次使用，尤其在真实的移动设备上)
2. 尽可能提高缓存效率, 尤其在发布更新时
3. 开发和部署的简易性

我们可以举一个简单的例子，来验证这种模式的实践：现在我们需要开发一个单页面应用(SPA)采用以下结构:
* 应用的主入口，文件非常小，资源由不同的网址提供，会被缓存，后续进入不会重新下载。
* 应用可以切割为顶级路由，路由器，组件等等。
* 延迟加载应用的模块，模块可以是逻辑组件，也可以是视图模块。js负责在需要的时候动态导入模块。

打包结果：

![打包结果](https://static.gitpapa.com/1550130015600.jpg)

依赖示意:

![依赖示意](https://static.gitpapa.com/qwjhdgqjhwkh.png)

在这样结构化的工程下，以模块为单位的迭代和更新非常方便，那些没有更新仍在使用的模块依旧可以命中以前的缓存，从而提高访问效率。

### 保持进取

前端性能优化可以说一件集腋成裘的过程，许许多多的小优化可以帮助我们收获大大的不同，最直观的感受就是我们的页面可以比对手更快地打开，更好地体验。

当然作为回报，用户会记住我们的应用，另一方面我们拿来恰饭的kpi也可以打得高高的。


